; BSOD64 (C) Kroc Camen, 2019-2020
; licenced under BSD 2-clause
;===============================================================================
; BSOD64 is a "blue screen of death" for C64 programs. why would you want that?
;
; ...
;
; DESIGN GOALS:
;-------------------------------------------------------------------------------
; * completely self-contained:
; - no external dependencies
; - does not need to be compiled into your own program
; - no need for compatibility with any particular assembler
; - can be loaded from disk using BASIC
; - resides in "unused" memory ($C000..$E000)
;
; * small:
; - maximum limit of 4 KB code
; - favours small code over speed / memory usage
; - uses only official KERNAL calls / addresses, so should work with
;   alternative ROMs such as Jiffy DOS, Dolphin DOS, C128 &c.
;
!to     "bsod64.prg"

!zone   bsod64 {

!source "system.acme"

;===============================================================================
!addr {
; when BSOD64 is invoked, the areas of memory that BSOD64 need to re-use are
; copied to the RAM under the I/O space. since this RAM is very difficult to
; use, it's the most likely "unused" RAM on the system and the last area a
; developer will want to utilise before any other
;
.frzn                   = $d000 ; (base address of frozen data)
.frzn_zp                = $d000 ; backup of zero-page ($0000-$00FF)
.frzn_stack             = $d100 ; backup of stack ($0100-$1FF)
.frzn_work              = $d200 ; backup of KERNAL work-RAM ($0200-$02FF)
.frzn_vectors           = $d300 ; backup of KERNAL/BASIC vectors ($0300-$03FF)
.frzn_screen            = $d400 ; backup of text screen ($0400-$07FF)
.frzn_color             = $d800 ; backup of colour RAM ($D800-$DBFF)
.frzn_vic               = $dc00 ; backup of VIC-II registers (46-bytes)

;-------------------------------------------------------------------------------
; depending on how BSDO64 is invoked, different actions
; must be taken during the freeze and defrost
;
.bsod_is_jsr            = $cfff ; BSOD64 invoked by JSR? $00 = no, $FF = yes
.bsod_is_brk            = $cffe ; BRK interrupt flag: $00 = no, $FF = yes

.bsod_a                 = $cffd ; working copy of the A register
.bsod_x                 = $cffc ; working copy of the X register
.bsod_y                 = $cffb ; working copy of the Y register
.bsod_sp                = $cffa ; working copy of the stack pointer
.bsod_pc                = $cff8 ; working copy of the program counter
.bsod_pc_lo             = $cff8
.bsod_pc_hi             = $cff9
.bsod_f                 = $cff7 ; working copy of the processor flags

; address that appears at the top of the memory viewer window
; i.e. the current memory range (128-bytes) within the window;
; not to be confused with the cursor address which can be
; any specific byte within the window
;
.bsod_memview           = $cff5
.bsod_memview_lo        = $cff5
.bsod_memview_hi        = $cff6

; currently focused address in memory, i.e. the cursor
.bsod_memaddr           = $cff3
.bsod_memaddr_lo        = $cff3
.bsod_memaddr_hi        = $cff4

;-------------------------------------------------------------------------------
;;; working copy of the frozen processor status flags
;;!addr   zp_f            = $fe
;;; working copy of the frozen registers
;;!addr   zp_y            = $fd
;;!addr   zp_x            = $fc
;;!addr   zp_a            = $fb

;;; temporary stack pointer of the frozen stack i.e. a focus cursor, and not the
;;; origanl stack pointer at time of freeze nor the current system stack pointer
;;!addr   zp_sp           = $02

; address pointer used for printing memory values
; e.g. display the memory hexdump
.zp_addr                = $03
.zp_addr_lo             = $03
.zp_addr_hi             = $04
;;; as above, but tracks the "real" address
;;; rather than the virtual one
;;.zp_real                = $05
;;.zp_real_lo             = $05
;;.zp_real_hi             = $06

;-------------------------------------------------------------------------------
; address for string indexing
; ("pointer to memory allocated for current string variable")
.zp_str                 = $35
.zp_str_lo              = $35
.zp_str_hi              = $36

;===============================================================================
; where a JMP instruction is overwritten,
; this is the placeholder address
.null_addr              = $8888
}
; where an instruction operand is overwritten,
; this is the placeholder value
.NULL_VALUE             = $88

; terminators used for the string-printing routines:
;
.STR_END                = $00   ; standard terminator
.STR_POS                = $01   ; a string with screen co-ords follows
.STR_KEY                = $02   ; a key-identifier string follows
.STR_KEYPOS             = $03   ; as above, but also with screen co-ords


* = $c000
;===============================================================================
; install BSOD64's launch hooks:
; (`SYS 49152` / `jsr $c000`)
;
; this will alter the system interrupts to launch BSOD64 whenever the RESTORE
; key is pressed, or the BRK instruction is encountered in running code
; 
; if you are using your own interrupt code then you will need to include a
; small piece of code at the beginning of your IRQ / NMI routine to invoke
; BSOD64 -- see the comments for the `bsod_irq` routine below
;
bsod_basic:
        ;-----------------------------------------------------------------------
        jmp bsod_init

;===============================================================================
; invoke BSOD64 manually with a JSR:
; (`SYS 49155` / `jsr $c003`)
;
; THIS ASSUMES THE FOLLOWING STACK LAYOUT:
;
;       top  -> PC lo-byte              (pushed by JSR)
;               PC hi-byte              (pushed by JSR)
;
bsod_jsr:
        ;-----------------------------------------------------------------------
        ; push the processor status and registers to the stack
        ; to normalise the stack layout for BSOD64
        jmp bsod_push

;===============================================================================
; invoke BSOD64 from an interrupt (IRQ/NMI/BRK) environment:
; (`jmp $c006`)
;
; THIS ASSUMES THE FOLLOWING STACK LAYOUT:
;
;       top  -> Y register              (pushed by your IRQ/NMI routine)
;               X register              (pushed by your IRQ/NMI routine)
;               A register              (pushed by your IRQ/NMI routine)
;               processor status        (pushed by hardware interrupt)
;               PC lo-byte              (pushed by hardware interrupt)
;               PC hi-byte              (pushed by hardware interrupt)
;
bsod_irq:
        ;-----------------------------------------------------------------------
        ; disable interrupts first!
        ; we must stop any more host code from running!
        sei
        ; set the flag indicating how BSOD64 was launched
        ; in this case, by IRQ (the default), not by JSR.
        ; the BRK bit will be checked later
        lda # $00
        sta .bsod_is_jsr


;===============================================================================
; 888888b.    .d8888b.   .d88888b.  8888888b.   .d8888b.      d8888
; 888  "88b  d88P  Y88b d88P" "Y88b 888  "Y88b d88P  Y88b    d8P888
; 888  .88P  Y88b.      888     888 888    888 888          d8P 888
; 8888888K.   "Y888b.   888     888 888    888 888d888b.   d8P  888
; 888  "Y88b     "Y88b. 888     888 888    888 888P "Y88b d88   888
; 888    888       "888 888     888 888    888 888    888 8888888888
; 888   d88P Y88b  d88P Y88b. .d88P 888  .d88P Y88b  d88P       888
; 8888888P"   "Y8888P"   "Y88888P"  8888888P"   "Y8888P"        888
;===============================================================================
; freeze the state of the machine:
; (NEVER CALL THIS DIRECTLY -- *ALWAYS* use `bsod_jsr` or `bsod_irq` above)
;
bsod_freeze:
        ;-----------------------------------------------------------------------
        ; we do not know if decimal mode was in use, turn it off before
        ; we do any math (this is a hardware-flaw with the NMOS 6502)
        cld
        ; get the stack pointer
        tsx
        stx orig_sp             ; keep an unmodified copy
        stx .bsod_sp            ; make a working copy
        ; backup the registers that were pushed on to the stack by the
        ; IRQ/NMI routine (or BSOD64 iteself in the case of `bsod_jsr`)
        lda .stack+1, x         ; top of stack
        sta orig_y              ; keep an unmodified copy of Y
        sta .bsod_y             ; make a working (modifiable) copy
        lda .stack+2, x         ; 2nd item on stack
        sta orig_x              ; keep an unmodified copy of X
        sta .bsod_x             ; make a working (modifiable) copy
        lda .stack+3, x         ; 3rd item on stack
        sta orig_a              ; keep an unmodified copy of A
        sta .bsod_a             ; make a working (modifiable) copy

        ; below the registers should be the processor status
        ; at the time of interrupt. we will need this to determine
        ; if BSOD64 was invoked by a BRK instruction
        lda .stack+4, x
        sta orig_f              ; keep an unmodified copy
        sta .bsod_f             ; make a working (modifiable) copy

        ; and lastly the program-counter. for now we do not make a working
        ; copy because the address of the program counter varies depending
        ; on calling method (i.e. JSR/IRQ/BRK) and we will rectify that
        ; after the freeze is complete
        lda .stack+5, x         ; program counter lo-byte
        sta orig_pc_lo          ; keep an unmodified copy
        lda .stack+6, x         ; program counter hi-byte
        sta orig_pc_hi          ; keep an unmodified copy

        ; freeze low-memory:
        ;-----------------------------------------------------------------------
        ; the area we will backup to is under I/O, so before we can write there
        ; we need to change the memory layout. first we backup the processor
        ; port, and then change memory layout to turn off I/O
        ;
        ; the "data direction register" determines what bits of the processor
        ; port can be written to. this is important to make use of because the
        ; Datasette control lines are part of the processor port and you don't
        ; want to play around with the tape when changing memory layout
        ;
        ; we actually want to stop the tape motor when freezing BSOD64
        ; so we set the data-direction register to allow us to turn off bit 5
        ;
        lda .zp+0               ; current CPU data-direction register
        sta orig_cpu_ddir       ; backup within BSOD64's code-area
        lda # %00101111         ; reset the data-direction register,
        sta .zp+0               ; to its default value
        lda .zp+1               ; current CPU port value
        sta orig_cpu_port       ; backup within BSOD64's code-area
        ;     %--11----         = Datasette motor & buttons off
        ;     %-----1--         = use I/O instead of char ROM
        ;     $------00         = I/O, KERNAL and BASIC ROMs off
        lda # %00110100
        sta .zp+1
        
        ; backup the low eight pages of memory
        ldx # 0
        ; backup the zero-page
-       lda .zp, x
        sta .frzn_zp, x
        ; backup the original stack. since BSOD64 will be using the stack
        ; too, we will want to take a copy of the stack at freeze-time
        lda .stack, x
        sta .frzn_stack, x
        ; backup the KERNAL/BASIC work RAM at $0200-$02FF
        lda .work, x
        sta .frzn_work, x
        ; backup the KERNAL/BASIC vectors at $0300-$03FF
        lda .vector, x
        sta .frzn_vectors, x
        ; backup the original text screen at $0400-$07FF
        lda .screen+$000, x
        sta .frzn_screen+$000, x
        lda .screen+$100, x
        sta .frzn_screen+$100, x
        lda .screen+$200, x
        sta .frzn_screen+$200, x
        lda .screen+$300, x
        sta .frzn_screen+$300, x
        ; rinse and repeat
        dex
        bne -

        ; with KERNAL off, we can back up the hardware vectors underneath:
        ; the non-maskable interrupt, wired to the RESTORE key & CIA2
        lda .cpu_nmi_lo
        sta orig_nmi_lo
        lda .cpu_nmi_hi
        sta orig_nmi_hi
        ; whilst the reset vector is never used after power-on,
        ; the host program may have modified it for its own uses
        lda .cpu_rst_lo
        sta orig_rst_lo
        lda .cpu_rst_hi
        sta orig_rst_hi
        ; the interrupt request vector, wired to CIA1 and VIC-II
        lda .cpu_irq_lo
        sta orig_irq_lo
        lda .cpu_irq_hi
        sta orig_irq_hi

        ; freeze VIC-II:
        ;-----------------------------------------------------------------------
        ; backup the VIC-II state before we start changing the screen
        ;
        ldx # $2e               ; number of VIC-II registers
-       inc .zp+1               ; enable the I/O shield for VIC-II registers
        lda .vic, x
        dec .zp+1               ; enable RAM under the I/O shield
        sta .frzn_vic, x
        dex
        bpl -

        ; backup colour RAM:
        ;-----------------------------------------------------------------------
        ; this is done in four stripes to avoid using a nested loop. note that
        ; because BSOD64 stores the frozen machine state under I/O, we have to
        ; turn I/O on & off for each read + write. whilst this is not ideal,
        ; it is the most-likely-to-be-unused memory available to us
        ;
        ldx # 0
-       inc .zp+1               ; enable the I/O shield for VIC-II registers
        lda .vic_color  + $000, x
        dec .zp+1               ; enable RAM under the I/O shield
        sta .frzn_color + $000, x
        inc .zp+1               ; enable the I/O shield for VIC-II registers
        lda .vic_color  + $100, x
        dec .zp+1               ; enable RAM under the I/O shield
        sta .frzn_color + $100, x
        inc .zp+1               ; enable the I/O shield for VIC-II registers
        lda .vic_color  + $200, x
        dec .zp+1               ; enable RAM under the I/O shield
        sta .frzn_color + $200, x
        inc .zp+1               ; enable the I/O shield for VIC-II registers
        lda .vic_color  + $300, x
        dec .zp+1               ; enable RAM under the I/O shield
        sta .frzn_color + $300, x
        dex
        bne -

        ; reset machine state:
        ;-----------------------------------------------------------------------
        lda # %00110111         ; enable BASIC,
        sta .zp+1               ; KERNAL & I/O

        ; this KERNAL routine erases pages 0, 1, & 2, runs a memory test,
        ; and configures BASIC limits. it sets the page number for screen
        ; memory to $04 just before it exits
        ;;jsr .kernal_ramtas

        ; restore the default vector table at $0314-$0333
        jsr .kernal_restor

        ; re-initialise VIC-II
        jsr .kernal_scinit

        ; a BSOD must be blue...
        lda # .VIC_BLUE
        sta .vic+VIC_SCREEN_BORDER
        sta .vic+VIC_SCREEN_BKGRND
        ; we can now hide the screen whilst we continue to work
        lda # %00001011         ; 25 rows, screen off
        sta .vic+VIC_SCREEN_VERT

        ; re-initialise CIAs, get interrupts running again
        jsr .kernal_ioinit

        lda # %00011011         ; 25 rows, screen on
        sta .vic+VIC_SCREEN_VERT

        ; configure working environment
        ;-----------------------------------------------------------------------
        ; put handlers in place for interrupts whenever we turn off the KERNAL
        ;
        sei                     ; first, disable interrupts

        ; install the NMI handler
        ;;lda #< bsod_nmi_kernalon
        ;;sta .vectors+VECTOR_NMI+0
        ;;lda #> bsod_nmi_kernalon
        ;;sta .vectors+VECTOR_NMI+1

        lda #< bsod_nmi_nokernal
        sta .cpu_nmi_lo
        lda #> bsod_nmi_nokernal
        sta .cpu_nmi_hi

        ; install the IRQ handler
        ;;lda #< bsod_irq_kernalon
        ;;sta .vectors+VECTOR_IRQ+0
        ;;sta .vectors+VECTOR_BRK+0
        ;;lda #> bsod_irq_kernalon
        ;;sta .vectors+VECTOR_IRQ+1
        ;;sta .vectors+VECTOR_BRK+1

        lda #< bsod_irq_nokernal
        sta .cpu_irq_lo
        lda #> bsod_irq_nokernal
        sta .cpu_irq_hi
        
        ; enable interrupts and hope
        ; the machine doesn't crash
        cli                     ; enable interrupts

        ;-----------------------------------------------------------------------
        ; make a note if BSOD64 was
        ; invoked by a BRK instruction
        ;
        lda .bsod_f             ; processor state before interrupt
        and # %00010000         ; isolate the BRK bit
        beq +                   ; use $00 for non-BRK
        lda # $ff               ; use $FF for BRK
+       sta .bsod_is_brk        ; we can easily refer to this in the future
        
        ; copy the original program counter to a working copy
        ; and add 1 to show the actual resume point in code
        ; (the 6502 auto-increments the PC upon RTS/RTI)
        ;
        clc
        lda orig_pc_lo
        adc # 1
        sta .bsod_pc_lo
        lda orig_pc_hi
        adc # 0
        sta .bsod_pc_hi

        ; WARNING: the program counter on the stack will be 'off' by a
        ;          differing amount depending on how BSOD64 was invoked!
        ;
        ; the 6502 processor always auto-increments the program counter when
        ; executing an RTS or RTI instruction, so the address pushed on the
        ; stack is always one-less than the next instruction in the code
        ;
        ; however -- a hardware bug in the BRK instruction causes the 6502
        ; to always add 2 to the program counter pushed to the stack
        ;
        ; in order for BSOD64 to unfreeze the machine state and resume,
        ; it needs to normalise the program counter it works with
        ;
        ; note that when invoking BSOD64 by JSR the BRK-bit is always set
        ; due to the use of PHP to push the processor status to the stack
        ; which always sets the BRK-bit
        ;
        bit .bsod_is_jsr        ; invoked by JSR and not an interrupt?
        bmi @debug              ; if yes, skip over BRK-handling of PC
        bit .bsod_is_brk        ; check the BRK state
        bpl @debug              ; skip if not a BRK call

        ; BRK call: fix the program
        ; counter by subtracting 2
        sec
        lda .bsod_pc_lo
        sbc # 2
        sta .bsod_pc_lo
        bcs +
        dec .bsod_pc_hi

        ; go display the crash-screen
+       jsr bsod_BSOD

        ; configure debugger:
        ;-----------------------------------------------------------------------
        ; set the memory cursor on the frozen program counter, i.e.
        ; the memory viewer window will be focused on the freeze-point
@debug: lda .bsod_pc_lo
        sta .bsod_memaddr_lo
        lda .bsod_pc_hi
        sta .bsod_memaddr_hi

        ; the memory viewer window is always aligned to the nearest 8-bytes;
        ; take the cursor address and round it to the nearest 8-bytes
        lda .bsod_memaddr_lo
        and # %11111000         ; align to every 8 bytes
        sta .bsod_memview_lo
        lda .bsod_memaddr_hi
        sta .bsod_memview_hi

;===============================================================================
; redraw the entire BSOD64 screen
;
bsod_redraw:
        ;-----------------------------------------------------------------------
        ; print the static elements of the screen
        ; (title, legends, key-commands etc)
        jsr bsod_print_str_inline
            ; configure screen + PETSCII
            !pet    .PET_CLR        ; clear the screen
            !pet    .PET_LCASE      ; switch to lower-case
            !pet    .PET_CASEOFF    ; disable case-switching via SHIFT+C=
            ; BSOD64 title
            !pet    .PET_CYAN, "BSOD64v0.0"
            !pet    .PET_GREEN
            ; registers legend
            !pet    .STR_POS, 2, 18, "PC:  A: X: Y:"
            ; flags legend "nv-bdiz"
            !pet    .STR_POS, 2, 32, "nv-bdizc"
            ; banks legend
            !pet    .STR_POS, 2, 9, "89ABCDEF"

            ; write the menu on the bottom of the screen
            !byte   .STR_KEYPOS, 24, 0
            !pet    .PET_F1, "RAM ", .STR_KEY
            !pet    .PET_F3, "VIC ", .STR_KEY
            !pet    .PET_F5, "DISK"
            ; registers title
            !pet    .STR_KEYPOS, 0, 18, "R", "REGISTERS"
            ; flags title
            !pet    .STR_KEYPOS, 0, 32, "F", "FLAGS"
            ; stack title
            !pet    .STR_KEYPOS, 5, 32, "S", "STACK"
            ; banks title
            !pet    .STR_KEYPOS, 2, 0, "B", "BANKS"
            ; memory viewer title
            !byte   .STR_KEYPOS, 5, 0
            !pet    "M", "MEMORY ", .STR_KEY
            !pet    "G", "GOTO", .STR_END

        ; draw the lines across the screen
        ldx # 39
        ldy # $63
-       lda # $64
        sta .screen+( 6 * 40), x
        tya
        sta .screen+(23 * 40), x
        ; add colour
        lda # .VIC_CYAN
        sta .vic_color+( 6 * 40), x
        sta .vic_color+(23 * 40), x
        dex
        bpl -

        ; draw the box for how BSOD64 was invoked:
        ; prepare the screen position / colour
        jsr bsod_print_str_inline_pos
            !byte   0, 14
            !pet    .PET_LTRED, .PET_RVSON
            !pet    .STR_END
        
        ; JSR overrides all other possibilities because the use of PHP
        ; to capture the processor flags when invoking by JSR causes
        ; the BRK bit to always be set
        bit .bsod_is_jsr
        bpl +
        ; JSR:
        jsr bsod_print_str_inline
            !pet    "JSR", .STR_END
        bcc @data               ; (always branches)

        ; check the break-bit
+       bit .bsod_is_brk
        bpl +
        ; BRK:
        jsr bsod_print_str_inline
            !pet    "BRK", .STR_END
        bcc @data                              ; (always branches)
        
+       ;IRQ:
        jsr bsod_print_str_inline
            !pet    "IRQ", .STR_END

        ; set the colour ready for filling in the data
@data:  jsr bsod_print_str_inline
            !pet    .PET_RVSOFF
            !pet    .PET_LTBLUE, .STR_END

        ; redraw the various windows' data
        jsr bsod_redraw_registers
        jsr bsod_redraw_flags
        jsr bsod_redraw_banks
        jsr bsod_redraw_stack
        jsr bsod_redraw_memory

bsod_input:
        ;-----------------------------------------------------------------------
        ; scan the keyboard, placing any active key into the buffer
        jsr .kernal_scnkey
        ; read a key from the keyboard buffer
        jsr .kernal_getin

@down   cmp # $11               ; cursor down
        bne @up

        clc
        lda .bsod_memview_lo
        adc # 8
        sta .bsod_memview_lo
        bcc +
        inc .bsod_memview_hi
+       jsr bsod_redraw_memory
        jmp bsod_input

@up     cmp # $91               ; cursor up
        bne bsod_input

        sec
        lda .bsod_memview_lo
        sbc # 8
        sta .bsod_memview_lo
        bcs +
        dec .bsod_memview_hi
+       jsr bsod_redraw_memory
        jmp bsod_input

        jmp *

;===============================================================================
; set the cursor positon:
; (save a byte every time we have to do this)
;
bsod_set_cursor:
        ;-----------------------------------------------------------------------
        clc                     ; = set cursor
        jmp .kernal_plot        ; call KERNAL to position cursor

;===============================================================================
; redraw the register window
;
bsod_redraw_registers:
        ;-----------------------------------------------------------------------
        ; registers:
        ldx # 3
        ldy # 23
        lda .bsod_a
        jsr bsod_print_hex8_pos
        lda # ' '
        tay
        jsr .kernal_chrout
        lda .bsod_x
        jsr bsod_print_hex8
        tya
        jsr .kernal_chrout
        lda .bsod_y
        jsr bsod_print_hex8

        ; program counter value:
        ldy # 18                ; column; X should already be 3
        jsr bsod_set_cursor

        lda .bsod_pc_hi
        ldx .bsod_pc_lo
        jsr bsod_print_hex16

        rts

;===============================================================================
; redraw the flags window:
;
bsod_redraw_flags:
        ;-----------------------------------------------------------------------
        ; print the processor flags
        ;
        ldy # 32
        ldx # 3
        jsr bsod_set_cursor

        lda .bsod_f
        sec
        jsr bsod_print_bin8

        rts

;===============================================================================
; redraw the banks (I/O, ROMs) window:
;
bsod_redraw_banks:
        ;-----------------------------------------------------------------------
        ; draw the memory layout:
        ; position cursor
        ldy # 9                 ; screen column
        ldx # 3                 ; screen row
        jsr bsod_set_cursor

        ; set reverse block printing
        lda # .PET_RVSON
        jsr .kernal_chrout

        ; default blank (no banked in ROM) character
        lda # ' '
        sta @b+1
        sta @i+1
        sta @k+1
        pha

        ; TODO: detect cart ROM
        jsr .kernal_chrout      ; cart ROM LO ($8000-$8FFF)
        jsr .kernal_chrout      ; cart ROM LO ($9000-$9FFF)
        
        ; read the processor port state from the original zero-page
        ; (note that this is under the I/O range, so we use our routine
        ;  that will read the frozen equivalent of a real address)
        ;
        lda #< .zp+1
        ldx #> .zp+1
        jsr bsod_get_frzn       ; read "$0001" from the frozen state ($D001)
        and # %00000011         ; we only care about the bottom bits
        beq @print              ; %00 = all RAM, nothing else

        ; any non-zero value implies
        ; that the I/O shield is on
        ;
        ldy # 'I'               ; use an "i" in bank D to indicate I/O on
        sty @i+1

        sec
        sbc # 1
        beq @print

        ldy # 'K'               ; use a "k" in banks E & F for KERNAL on
        sty @k+1

        sbc # 1
        beq @print

        ldy # 'B'               ; use a "b" in banks A & B for BASIC on
        sty @b+1

@print:
        ;-----------------------------------------------------------------------
@b      lda # $21
        jsr .kernal_chrout      ; BASIC ROM ($A000-$AFFF)
        jsr .kernal_chrout      ; BASIC ROM ($B000-$BFFF)
        pla
        jsr .kernal_chrout      ; $C000 is always RAM
@i      lda # $21
        jsr .kernal_chrout      ; I/O ($D000-$DFFF)
@k      lda # $21
        jsr .kernal_chrout      ; KERNAL ROM ($E000-$EFFF)
        jsr .kernal_chrout      ; KERNAL ROM ($F000-$FFFF)

        lda # .PET_RVSOFF
        jsr .kernal_chrout
        
        rts

;===============================================================================
; redraw the stack window:
;
bsod_redraw_stack:
        ;-----------------------------------------------------------------------
        ; set cursor to first line
        lda # 7
        sta @line
        ; get the frozen stack pointer
        ldy .bsod_sp

-       jsr bsod_print_str_inline_pos
@line       !byte   7, 32
            !pet    .PET_PURPLE, .STR_END
        
        ; is this line the top of the stack at freeze-time?
        cpy .bsod_sp
        bne +
        lda # "@"
       +bit_skip2

+       lda # " "
        jsr .kernal_chrout
        jsr bsod_print_str_inline
            !pet    .PET_GREEN, "1", .STR_END
        tya
        jsr bsod_print_hex8

        jsr bsod_print_str_inline
            !pet    .PET_LTBLUE, " ", .STR_END

        sei                     ; disable interrupts
        dec .zp+1               ; turn off BASIC,
        dec .zp+1               ; then KERNAL
        dec .zp+1               ; and then I/O
        lda .frzn_stack+1, y
        inc .zp+1               ; turn on I/O
        inc .zp+1               ; then KERNAL,
        inc .zp+1               ; and then BASIC
        cli                     ; enable interrupts
        jsr bsod_print_hex8     ; print the value
        iny
        beq +

        ldx @line
        inx
        stx @line
        cpx # 23
        bcc -

+       ; TODO: handle hitting the bottom of the stack ($1FF);
        ;       unused lines will have to be cleared if the stack is shallow
        rts

;===============================================================================
; redraw the memory window:
;
bsod_redraw_memory:
        ;-----------------------------------------------------------------------
        ; set the address to begin printing lines at
        lda .bsod_memview_lo
        sta .zp_addr_lo
        lda .bsod_memview_hi
        sta .zp_addr_hi

        ; set cursor to first line
        ldy # 0
        ldx # 7
        jsr bsod_set_cursor

        ; print the hex-dump
        ldy # 16                ; number of lines to print
-       jsr bsod_print_hexline  ; print 8-bytes
        dey
        bne -

        rts

;===============================================================================
; print a row of memory values:
;
bsod_print_hexline:
        ;-----------------------------------------------------------------------
        sty @y+1                ; preserve Y-register

        ; print the gutter
        jsr bsod_print_str_inline
            !pet    .PET_GREEN, "  $"
            !byte   .STR_END

        ; print the memory address
        lda .zp_addr_hi
        ldx .zp_addr_lo
        jsr bsod_print_hex16

        lda # .PET_LTBLUE
        jsr .kernal_chrout

        ldy # 8                 ; print 8-bytes
-       lda # ' '               ; print space between bytes
        jsr .kernal_chrout
        lda .zp_addr_lo
        ldx .zp_addr_hi
        jsr bsod_get_frzn
        jsr bsod_print_hex8
        ; move to the next byte
        inc .zp_addr_lo
        bcc +
        inc .zp_addr_hi
+       dey
        bne -

        lda # $0d
        jsr .kernal_chrout

@y      ldy # .NULL_VALUE
        rts

;===============================================================================
; read the value of an address from the frozen state:
; i.e. redirect addresses $0000-$07FF to $D000-$D7FF
; (also this must always read RAM and not I/O or ROM)
;
;       A = original address lo-byte
;       X = original address hi-byte
;
; returns:
;       A = value of address from frozen state
;
bsod_get_frzn:
        ;-----------------------------------------------------------------------
        ; put aside the lo-byte as we check the hi-byte first
        pha
        
        ; the lower four pages of the machine
        ; were backed up and now stored elsewhere
        txa
        cmp #> .screen+$400
        bcs +                   ; if address > $07FF then return actual RAM

        ; if the address is within low-RAM then
        ; redirect the address to the frozen copy in high-RAM
        clc
        adc #> .frzn

+       sta @addr+2             ; set address hi-byte to read
        pla                     ; retreive the lo-byte
        sta @addr+1             ; set address lo-byte to read

        sei                     ; disable interrupts
        ldx # %00110100         ; turn off BASIC,
        stx .zp+1               ; KERNAL, and I/O

@addr   lda .null_addr          ; read the RAM address

        ldx # %00110111         ; turn on KERNAL,
        stx .zp+1               ; BASIC, and I/O
        cli                     ; enable interrupts

        rts

;===============================================================================
; print a 16-bit value as PETSCII hexadecimal:
;
;       A = value, hi-byte
;       X = value, lo-byte
;
bsod_print_hex16:
        ;-----------------------------------------------------------------------
        jsr bsod_print_hex8     ; print hi-byte first, X will be preserved
        txa                     ; switch to value's lo-byte
        jmp bsod_print_hex8

;===============================================================================
; print a byte as PETSCII hexadecimal at a given screen row/column:
;
;       A = byte value
;       X = screen row
;       Y = screen col
;
bsod_print_hex8_pos:
        ;-----------------------------------------------------------------------
        pha                     ; put aside original value
        jsr bsod_set_cursor     ; position the cursor
        pla                     ; retrieve original value

;===============================================================================
; print a byte as PETSCII hexadecimal:
;
;       A = byte value
;
;       X, Y are preserved
;
bsod_print_hex8:
        ;-----------------------------------------------------------------------
        stx @x+1                ; preserve X-register
        sty @y+1                ; preserve Y-register

        sed                     ; enable decimal mode
        pha                     ; put original value aside

        lsr                     ; shift upper nybble down
        lsr                     ; ...
        lsr                     ; ...
        lsr                     ; ...
        cmp # 9+1
        adc # $30               ; rebase to PETSCII '0' and above
        jsr .kernal_chrout
        iny

        pla                     ; retrieve original value
        and # $0f               ; extract lower nybble
        cmp # 9+1
        adc # $30               ; rebase to PETSCII '0' and above
        jsr .kernal_chrout
        iny

        cld                     ; disable decimal mode
@x      ldx # .NULL_VALUE       ; restore X register
@y      ldy # .NULL_VALUE       ; restore Y register

        rts

;===============================================================================
; print a byte as PETSCII binary:
;
;       A = value
;      -c = use 0/1 digits
;      +c = use -/* digits
;       X = screen row
;       Y = screen col
;
bsod_print_bin8:
        ;-----------------------------------------------------------------------
        ldy # 8                 ; print 8-bits

        ; check the carry state. if carry is set binary
        ; digits will be printed as "-" = 0 and "*" = 1
        bcs @sym                ; carry set = use symbols

        ; print "0" & "1" digits
        ;-----------------------------------------------------------------------
@dig    asl                     ; pop a bit off the value
        tax                     ; remember remainder for next loop
        lda # $30               ; PETSCII '0'
        adc # 0                 ; PETSCII '1' if bit was 1
        jsr .kernal_chrout      ; print digit

        txa                     ; retrieve remaining value before looping
        dey                     ; 1 digit down
        bne @dig                ; any more left?

        rts

        ; print "-" & "*" digits
        ;-----------------------------------------------------------------------
@sym    asl                     ; pop a bit off the value
        tax                     ; remember remainder for next loop

        bcc +                   ; is bit 0 or 1?
        lda # $2a               ; PETSCII '*'
        !byte $2c               ; `bit $....` (skip next 2-byte instruction)
+       lda # $2d               ; PETSCII '-'
        jsr .kernal_chrout
        
        txa                     ; retrieve remaining value before looping
        dey                     ; 1 digit down
        bne @sym                ; any more left?

        rts

;===============================================================================
; print a key guide, e.g. "R:REGISTERS":
;
; having a routine for this does away with the need to store
; the same colour-changing bytes for every key string
;
bsod_print_key_inline_pos:
        ;-----------------------------------------------------------------------
        ; clear carry to indicate an embedded
        ; position in the string
        clc
        ; skip the next instruction (`clc`)
        ; when we fall into the routine below
       +bit_skip1

bsod_print_key_inline:
        ;-----------------------------------------------------------------------
        ; set carry to indicate 'no embedded position'
        sec

        ; preserve registers at the end of the inline string
        ; printing routine, which is where we will exit
        stx bsod_print_str_inline_pos__x
        sty bsod_print_str_inline_pos__y

        ; get the address of the string from the stack.
        ; if carry is clear, the row/col will be read
        ; from the first two bytes of the string
        jsr bsod_stack_string
        
bsod_print_key_inline_print:
        ;-----------------------------------------------------------------------
        ; print the key
        lda # .PET_WHITE
        jsr .kernal_chrout
        lda (.zp_str), y
        ; handle some special codes that require more than one character:
        cmp # .PET_F1           ; is the key F1 or above?
        bcc +
        cmp # .PET_F8+1         ; is it F1 through F8?
        bcs +
        tax                     ; keep that Fx keycode...

        ; print the F for Function, first
        lda # "f"
        jsr .kernal_chrout
        ; turn an F1-F8 PETSCII code ($85-$8C)
        ; into a PETSCII number ($31-$38)
        txa                     ; retrieve the Fx keycode
        sbc # $53               ; move into "1"-"8" range

        ; print the key letter
+       jsr .kernal_chrout
        ; print the colon separating key and function
        ; (note: cannot nest `bsod_print_str_inline` calls!)
        lda # .PET_LTBLUE
        jsr .kernal_chrout
        lda # ":"
        jsr .kernal_chrout
        ; print the remainder of the string in yellow
        lda # .PET_YELLOW
        jsr .kernal_chrout

        iny
        jmp bsod_print_str_inline_pos__print

;===============================================================================
; print a null-terminated PETSCII string, at the current cursor location,
; where the string data immediately follows the call to this routine!
;
; preserves:    X, Y
;
bsod_print_str_inline:
        ;-----------------------------------------------------------------------
        ; set carry to indicate 'no embedded position'
        sec
        ; skip the next instruction (`clc`)
        ; when we fall into the routine below
       +bit_skip1
        
;===============================================================================
; print a null-terminated PETSCII string that includes the row+col position
; in the first two bytes, where the string data immediately follows the call
; to this routine!
;
; preserves:    X, Y
;
bsod_print_str_inline_pos:
        ;-----------------------------------------------------------------------
        ; clear carry to indicate that the cursor position
        ; is embdedded in the string
        clc

        ; preserve X & Y
        stx @x+1
        sty @y+1

        ; get the address + row/col of the string from the stack
        jsr bsod_stack_string

@print  lda (.zp_str), y
!addr   bsod_print_str_inline_pos__print = @print
        tax
        beq +                   ; .STR_END -- stop printing
        dex
        beq @next_pos           ; .STR_POS -- move cursor and continue printing
        dex
        beq @next_key           ; .STR_KEY -- print another key-command
        dex
        beq @next_keypos        ; .STR_KEYPOS -- move & print key-command

        jsr .kernal_chrout
        iny
        bne @print

        ; we will need to add the length of the inline string to the call
        ; address so as to 'step-over' those bytes and return execution to
        ; the point after the inline-string
        ;
+       tsx                     ; retrieve current stack position
        iny
        tya
        adc .stack+1, x
        sta .stack+1, x
        bcc @x
        inc .stack+2, x

@x      ldx # .NULL_VALUE
!addr   bsod_print_str_inline_pos__x = @x+1
@y      ldy # .NULL_VALUE
!addr   bsod_print_str_inline_pos__y = @y+1

        rts

@next_pos:
        ; read & set the cursor position
        ; from the next two bytes
        iny
        jsr bsod_stack_string_pos
        ; continue printing
        jmp @print

@next_key:
        ; print another key-command
        iny
        jmp bsod_print_key_inline_print

@next_keypos:
        ; set cursor and print another key-command
        iny
        jsr bsod_stack_string_pos
        jmp bsod_print_key_inline_print

;===============================================================================
; read an inline string address from the stack:
;
bsod_stack_string:
        ;-----------------------------------------------------------------------
        ; put aside the carry flag for later; this will cause
        ; the stack to look like this:
        ;       
        ; stack pointer ->  (unused stack value)
        ;               +1  processor status
        ;               +2  this routine's address, lo-byte
        ;               +3  this routine's address, hi-byte
        ;               +4  original call address for string, lo-byte
        ;               +5  original call address for string, hi-byte
        php

        tsx                     ; get current stack pointer
        clc                     ; we need to read the string address:
        lda .stack+4, x         ; read the lo-byte from the stack
        adc # 1                 ; add 1 to get to move into the inline string
        sta .zp_str_lo
        lda .stack+5, x
        adc # 0
        sta .zp_str_hi

        ldy # 0                 ; start with string-index of 0
        plp                     ; retrieve the original carry flag

        bcc bsod_stack_string_pos
        rts

bsod_stack_string_pos:
        ;-----------------------------------------------------------------------
        ; read the row & col bytes
        ;
        lda (.zp_str), y        ; read the row
        tax                     ; must be in X for KERNAL call
        iny
        tya
        pha
        lda (.zp_str), y        ; read the col
        tay                     ; must be in Y for KERNAL call

        jsr bsod_set_cursor     ; position the cursor

        pla
        tay
        iny                     ; new string index

        rts

;===============================================================================
; normalise the stack to appear the same as the interrupt call would:
; this reduces the complexity of handling the different methods
; of invoking BSOD64
;
; this generates the following stack profile:
;
;       top  -> Y register              (pushed by this routine)
;               X register              (pushed by this routine)
;               A register              (pushed by this routine)
;               processor status        (pushed by this routine)
;               PC lo-byte              (pushed by the JSR to BSOD64)
;               PC hi-byte              (pushed by the JSR to BSOD64)
;
bsod_push:
        ;-----------------------------------------------------------------------
        ; push the processor status to the stack
        ;
        ; even though an interrupt could occur between this instruction
        ; and the next, we need to capture the current interrupt flag state
        ; before changing it
        ;
        ; WARNING: the PHP instruction always sets the BRK bit! a flag is set
        ; (below) to indicate that BSOD64 was invoked by JSR instead of BRK
        ; to ensure that BSOD64 does not misinterpret the machine state --
        ; BRK adds 2 to the program counter and when defrosting the machine
        ; state, BRK would use an RTI to return whereas JSR would use RTS
        ;
        php
        ; disable interrupts
        sei
        ; push the registers
        pha
        txa
        pha
        tya
        pha
        ; set flag to indicate BSOD64 being invoked by JSR
        ; -- we will have to resume execution differently
        lda # $ff
        sta .bsod_is_jsr

        ; now begin the freeze
        jmp bsod_freeze

;===============================================================================
;
bsod_init:
        ;-----------------------------------------------------------------------
        rts

;===============================================================================
; interrupt handlers:
;
; when the KERNAL ROM is switched on, it controls the interrupt vectors at
; $FFFA-$FFFF. this means that there's some extra indirection that happens
; whenever an IRQ occurs. first, the KERNAL pushes A, X & Y onto the stack
; and then calls the vector at $0314; by default this is the routine that
; handles the BASIC interrupt, e.g. blinking the cursor. if the KERNAL is
; on but BASIC is off, the system will crash!
;
; unless you are writing a BASIC extension there is no reason to keep BASIC
; switched on (you can use the RAM underneath instead), therefore we must
; provide a routine to replace the BASIC interrupt. it doesn't have to do
; any actual work, just merely exit in the correct way, that is, restore
; the register from the stack and call `rti`. alternatively, one can jump
; to $EA81 which is the KERNAL's code to do the same, but I recommend
; against this because that assumes that the machine is a C64 with
; stock ROMs and this might not be the case!
;
bsod_irq_kernalon:
        ;-----------------------------------------------------------------------
        ; pull the registers from the stack
        ; (in reverse order)
        pla                     ; pull...
        tay                     ; ...Y
        pla                     ; pull...
        tax                     ; ...X
        pla                     ; pull A

bsod_irq_nokernal:
        ;-----------------------------------------------------------------------
        ; return from interrupt
        ; (restore processor flags, enable interrupts)
        rti

; likewise, without the KERNAL, the RAM underneath
; will determine the NMI handler (the RESTORE key)
;
bsod_nmi_kernalon:
        ;-----------------------------------------------------------------------
        ; pull the registers from the stack
        ; (in reverse order)
        pla                     ; pull...
        tay                     ; ...Y
        pla                     ; pull...
        tax                     ; ...X
        pla                     ; pull A

bsod_nmi_nokernal:
        ;-----------------------------------------------------------------------
        ; return from interrupt
        ; (restore processor flags, enable interrupts)
        rti

;===============================================================================
;
bsod_BSOD:
        ;-----------------------------------------------------------------------
        ; print the "BSOD"
        ;
        jsr bsod_print_str_inline
            !pet    .PET_WHITE      ; set text-colour
            !pet    .PET_CLR        ; clear the screen
            !pet    .PET_UCASE      ; switch to upper-case
            !pet    .PET_CASEOFF    ; disable case-switching via SHIFT+C=
            ; print the sad face:
            !pet    $20, $20, $6e, .PET_RETURN
            !pet    $71, $20, $a5, .PET_RETURN
            !pet    $20, $20, $a5, .PET_RETURN
            !pet    $71, $20, $a5, .PET_RETURN
            !pet    $20, $20, $6d, .PET_RETURN
            !pet    .PET_RETURN, .PET_RETURN
            !pet    "break at $"
            !pet    .STR_END
        
        lda .bsod_pc_hi
        ldx .bsod_pc_lo
        jsr bsod_print_hex16

        jsr bsod_print_str_inline
            !pet    .PET_RETURN
            !pet    .PET_RETURN, .PET_RETURN
            !byte   .STR_END

        ; print error message?
        ;-----------------------------------------------------------------------
        ; check for an error message following the BRK:
        ;
        ; to idenitfy the bytes following the BRK as an error message, and not
        ; code, we check for a signature byte that could *not* be code, i.e.
        ; an illegal instruction
        ;
        ; when we read back the bytes following the frozen program counter,
        ; they could be underneath the BASIC or KERNAL ROM!
        ;
        sei                     ; disable interrupts
        lda # %00110100         ; turn off BASIC,
        sta .zp+1               ; KERNAL & I/O

        ; copy the frozen program counter
        ; into the zero-page for indexing
        lda .bsod_pc_lo
        sta .zp_str_lo
        lda .bsod_pc_hi
        sta .zp_str_hi

        ; read the first byte following the BRK
        ldy # 0
        lda (.zp_str), y
        iny

        ; we use $42 as our marker specifically because, whilst it causes a
        ; crash on a 6502 (and therefore can't be mistaken for code following
        ; the BRK), it is reserved on the 65C02 & 65816 as "WDM", an escape-
        ; code for future expansions and shouldn't occur in practice when it
        ; comes to Commodore systems (e.g. Super-CPU)
        ;
        cmp # $42               ; is the byte following the BRK, $42?
        bne @nomsg              ; if not, skip over printing error message

-       lda (.zp_str), y        ; read a character from the string
        beq +                   ; if $00, stop printing

        ldx # %00110111         ; turn on I/O,
        stx .zp+1               ; KERNAL & BASIC

        jsr .kernal_chrout      ; print the character
        
        ldx # %00110100         ; turn off BASIC,
        stx .zp+1               ; KERNAL & I/O
        
        iny                     ; move to next character
        bne -                   ; (stops printing after 255 characters)

+       ; print CPU status:
        ;-----------------------------------------------------------------------
@nomsg: lda # %00110111         ; turn on I/O,
        sta .zp+1               ; BASIC & KERNAL
        cli                     ; enable interrupts

        jsr bsod_print_str_inline_pos
            !byte   20, 0
            !pet    .PET_WHITE      ; (error message may have changed colour)
            !pet    "a:$   x:$   y:$   sp:$"
            !pet    .PET_RETURN, .PET_RETURN
            !pet    "nv-bdizc", .PET_RETURN
            !byte   .STR_END

        ; print status flags
        lda orig_f
        sec
        jsr bsod_print_bin8

        ; print register values
        ldx # 20
        ldy # 3
        lda orig_a
        jsr bsod_print_hex8_pos
        ldy # 9
        lda orig_x
        jsr bsod_print_hex8_pos
        ldy # 15
        lda orig_y
        jsr bsod_print_hex8_pos
        ldy # 22
        lda orig_sp
        jsr bsod_print_hex8_pos

        jmp *
        rts

;===============================================================================
; BSOD64's backup of some C64 state at the point of BRK / NMI.
; this is used to minimize damage to the original stack
;
; unlike the other backup data (zero-page, stack, colour RAM),
; these are kept within the program code due to their sensitivity
; to corruption, and remain unmodified. working copies are made
; whilst BSOD64 is in use
;
orig_cpu_ddir:                  ; backup of the CPU data-direction port ($00)
        !byte   .NULL_VALUE
orig_cpu_port:                  ; backup of the CPU port ($01)
        !byte   .NULL_VALUE
orig_a:                         ; backup of the A register
        !byte   .NULL_VALUE
orig_x:                         ; backup of the X register
        !byte   .NULL_VALUE
orig_y:                         ; backup of the Y register
        !byte   .NULL_VALUE
orig_sp:                        ; backup of the stack pointer
        !byte   .NULL_VALUE
orig_pc:                        ; backup of the program counter
orig_pc_lo:
        !byte   .NULL_VALUE
orig_pc_hi:
        !byte   .NULL_VALUE
orig_f:                         ; backup of the processor status (flags)
        !byte   .NULL_VALUE

orig_nmi:                       ; backup of the NMI hardware vector ($FFFA/B)
orig_nmi_lo:
        !byte   .NULL_VALUE
orig_nmi_hi:
        !byte   .NULL_VALUE

orig_rst:                       ; backup of the RESET hardware vector ($FFFC/D)
orig_rst_lo:
        !byte   .NULL_VALUE
orig_rst_hi:
        !byte   .NULL_VALUE

orig_irq:                       ; backup of the IRQ hardware vector ($FFFE/F)
orig_irq_lo:
        !byte   .NULL_VALUE
orig_irq_hi:
        !byte   .NULL_VALUE

;===============================================================================
bsod_defrost:
        ;-----------------------------------------------------------------------
        rts
}